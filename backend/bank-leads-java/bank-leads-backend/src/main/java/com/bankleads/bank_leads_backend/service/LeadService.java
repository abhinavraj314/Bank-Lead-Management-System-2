package com.bankleads.bank_leads_backend.service;

import com.bankleads.bank_leads_backend.model.Lead;
import com.bankleads.bank_leads_backend.repository.LeadRepository;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class LeadService {

    private static final Logger log = LoggerFactory.getLogger(LeadService.class);
    
    private final LeadRepository leadRepository;
    private final CanonicalFieldDeduplicationService canonicalFieldDeduplicationService;
    
    public Optional<Lead> findByLeadId(String leadId) {
        return leadRepository.findByLeadId(leadId);
    }
    
    @Transactional
    public UpsertResult upsertLead(Map<String, String> normalized, UpsertContext ctx) {
        // Check for existing lead
        Optional<Lead> existingOpt = findExistingLead(normalized);
        
        if (existingOpt.isPresent()) {
            Lead existing = existingOpt.get();
            // Defensive fix: some legacy leads may have leadId null/blank.
            // Mongo has a UNIQUE index on lead_id; null would collide on subsequent saves.
            ensureLeadId(existing);
            Lead merged = mergeLeadData(existing, normalized, ctx);
            ensureLeadId(merged);
            assertLeadIdOrThrow(merged);
            Lead saved = leadRepository.save(merged);
            return new UpsertResult("merged", saved);
        }
        
        // Create new lead
        Lead newLead = Lead.builder()
                // leadId generated by builder default / model invariant; do not accept CSV lead_id
                .name(normalized.get("name"))
                .phoneNumber(normalized.get("phone_number"))
                .email(normalized.get("email"))
                .aadharNumber(normalized.get("aadhar_number"))
                .sourceId(ctx.sourceId)
                .pId(ctx.pId)
                .createdAt(LocalDateTime.now())
                .mergedFrom(new ArrayList<>())
                .sourcesSeen(new ArrayList<>(Collections.singletonList(ctx.sourceId)))
                .productsSeen(new ArrayList<>(Collections.singletonList(ctx.pId)))
                .leadScore(null)
                .scoreReason(null)
                .build();

        // Defensive fix: guarantee leadId is never null/blank before insert.
        ensureLeadId(newLead);
        assertLeadIdOrThrow(newLead);
        
        Lead.MergeRecord initialMerge = Lead.MergeRecord.builder()
                .timestamp(LocalDateTime.now())
                .sourceId(ctx.sourceId)
                .pId(ctx.pId)
                .data(ctx.rawRow)
                .build();
        
        newLead.getMergedFrom().add(initialMerge);
        
        Lead saved = leadRepository.save(newLead);
        return new UpsertResult("inserted", saved);
    }

    private static void ensureLeadId(Lead lead) {
        if (lead == null) return;
        String id = lead.getLeadId();
        if (id == null || id.trim().isEmpty()) {
            log.error("Defensive: leadId was null/blank before save; generating new UUID");
            lead.setLeadId(UUID.randomUUID().toString());
        }
    }

    private static void assertLeadIdOrThrow(Lead lead) {
        if (lead == null) {
            throw new IllegalStateException("Lead is null before save");
        }
        String id = lead.getLeadId();
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalStateException("Lead leadId is null/blank before save");
        }
    }
    
    private Optional<Lead> findExistingLead(Map<String, String> normalized) {
        // Get deduplication config from canonical fields (dynamic)
        DeduplicationService.DeduplicationConfig config = 
            canonicalFieldDeduplicationService.buildConfigFromCanonicalFields();
        
        String email = normalized.get("email");
        String phone = normalized.get("phone_number");
        String aadhar = normalized.get("aadhar_number");
        
        // Try email if enabled in config
        if (config.isUseEmail() && email != null && !email.isEmpty()) {
            List<Lead> leads = leadRepository.findByEmail(email);
            if (!leads.isEmpty()) {
                log.debug("Found existing lead by email: {}", email);
                return Optional.of(leads.get(0));
            }
        }
        
        // Try phone if enabled in config
        if (config.isUsePhone() && phone != null && !phone.isEmpty()) {
            List<Lead> leads = leadRepository.findByPhoneNumber(phone);
            if (!leads.isEmpty()) {
                log.debug("Found existing lead by phone: {}", phone);
                return Optional.of(leads.get(0));
            }
        }
        
        // Try aadhar if enabled in config
        if (config.isUseAadhar() && aadhar != null && !aadhar.isEmpty()) {
            List<Lead> leads = leadRepository.findByAadharNumber(aadhar);
            if (!leads.isEmpty()) {
                log.debug("Found existing lead by aadhar: {}", aadhar);
                return Optional.of(leads.get(0));
            }
        }
        
        return Optional.empty();
    }
    
    private Lead mergeLeadData(Lead existing, Map<String, String> incoming, UpsertContext ctx) {
        // Fill missing fields
        if ((existing.getName() == null || existing.getName().isEmpty()) && incoming.get("name") != null) {
            existing.setName(incoming.get("name"));
        }
        if ((existing.getPhoneNumber() == null || existing.getPhoneNumber().isEmpty()) && incoming.get("phone_number") != null) {
            existing.setPhoneNumber(incoming.get("phone_number"));
        }
        if ((existing.getEmail() == null || existing.getEmail().isEmpty()) && incoming.get("email") != null) {
            existing.setEmail(incoming.get("email"));
        }
        if ((existing.getAadharNumber() == null || existing.getAadharNumber().isEmpty()) && incoming.get("aadhar_number") != null) {
            existing.setAadharNumber(incoming.get("aadhar_number"));
        }
        
        // Track source and product history
        if (!existing.getSourcesSeen().contains(ctx.sourceId)) {
            existing.getSourcesSeen().add(ctx.sourceId);
        }
        if (!existing.getProductsSeen().contains(ctx.pId)) {
            existing.getProductsSeen().add(ctx.pId);
        }
        
        // Store raw row for audit trail
        Lead.MergeRecord mergeRecord = Lead.MergeRecord.builder()
                .timestamp(LocalDateTime.now())
                .sourceId(ctx.sourceId)
                .pId(ctx.pId)
                .data(ctx.rawRow)
                .build();
        
        existing.getMergedFrom().add(mergeRecord);
        
        return existing;
    }
    
    public static class UpsertResult {
        private final String action; // "inserted" or "merged"
        private final Lead lead;
        
        public UpsertResult(String action, Lead lead) {
            this.action = action;
            this.lead = lead;
        }
        
        public String getAction() { return action; }
        public Lead getLead() { return lead; }
    }
    
    public static class UpsertContext {
        private final String pId;
        private final String sourceId;
        private final Object rawRow;
        
        public UpsertContext(String pId, String sourceId, Object rawRow) {
            this.pId = pId;
            this.sourceId = sourceId;
            this.rawRow = rawRow;
        }
        
        public String getPId() { return pId; }
        public String getSourceId() { return sourceId; }
        public Object getRawRow() { return rawRow; }
    }
}
