package com.bankleads.bank_leads_backend.service;

import com.bankleads.bank_leads_backend.model.Lead;
import com.bankleads.bank_leads_backend.model.Product;
import com.bankleads.bank_leads_backend.repository.LeadRepository;
import com.bankleads.bank_leads_backend.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class LeadService {

    private static final Logger log = LoggerFactory.getLogger(LeadService.class);
    
    private final LeadRepository leadRepository;
    private final CanonicalFieldDeduplicationService canonicalFieldDeduplicationService;
    private final ProductRepository productRepository;
    private final DeduplicationService deduplicationService;
    
    public Optional<Lead> findByLeadId(String leadId) {
        return leadRepository.findByLeadId(leadId);
    }
    
    @Transactional
    public UpsertResult upsertLead(Map<String, String> normalized, UpsertContext ctx) {
        // Check for existing lead using per-product deduplication config when available
        Optional<Lead> existingOpt = findExistingLead(normalized, ctx);
        
        if (existingOpt.isPresent()) {
            Lead existing = existingOpt.get();
            // Defensive fix: some legacy leads may have leadId null/blank.
            // Mongo has a UNIQUE index on lead_id; null would collide on subsequent saves.
            ensureLeadId(existing);
            Lead merged = mergeLeadData(existing, normalized, ctx);
            ensureLeadId(merged);
            assertLeadIdOrThrow(merged);
            Lead saved = leadRepository.save(merged);
            return new UpsertResult("merged", saved);
        }
        
        // Create new lead
        Lead newLead = Lead.builder()
                // leadId generated by builder default / model invariant; do not accept CSV lead_id
                .name(normalized.get("name"))
                .phoneNumber(normalized.get("phone_number"))
                .email(normalized.get("email"))
                .aadharNumber(normalized.get("aadhar_number"))
                .sourceId(ctx.sourceId)
                .pId(ctx.pId)
                .createdAt(LocalDateTime.now())
                .mergedFrom(new ArrayList<>())
                .sourcesSeen(new ArrayList<>(Collections.singletonList(ctx.sourceId)))
                .productsSeen(new ArrayList<>(Collections.singletonList(ctx.pId)))
                .leadScore(null)
                .scoreReason(null)
                .income(ctx.income)
                .creditScore(ctx.creditScore)
                .employmentType(ctx.employmentType)
                .loanAmount(ctx.loanAmount)
                .converted(ctx.converted)
                .build();

        // Defensive fix: guarantee leadId is never null/blank before insert.
        ensureLeadId(newLead);
        assertLeadIdOrThrow(newLead);
        
        Lead.MergeRecord initialMerge = Lead.MergeRecord.builder()
                .timestamp(LocalDateTime.now())
                .sourceId(ctx.sourceId)
                .pId(ctx.pId)
                .data(ctx.rawRow)
                .build();
        
        newLead.getMergedFrom().add(initialMerge);
        
        Lead saved = leadRepository.save(newLead);
        return new UpsertResult("inserted", saved);
    }

    private static void ensureLeadId(Lead lead) {
        if (lead == null) return;
        String id = lead.getLeadId();
        if (id == null || id.trim().isEmpty()) {
            log.error("Defensive: leadId was null/blank before save; generating new UUID");
            lead.setLeadId(UUID.randomUUID().toString());
        }
    }

    private static void assertLeadIdOrThrow(Lead lead) {
        if (lead == null) {
            throw new IllegalStateException("Lead is null before save");
        }
        String id = lead.getLeadId();
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalStateException("Lead leadId is null/blank before save");
        }
    }
    
    private Optional<Lead> findExistingLead(Map<String, String> normalized, UpsertContext ctx) {
        // Prefer per-product deduplication config (from Product.deduplicationFields).
        // Fallback to canonical-fields-based global config if product is missing or misconfigured.
        DeduplicationService.DeduplicationConfig config;
        
        String ctxPId = ctx != null ? ctx.getPId() : null;
        if (ctxPId != null && !ctxPId.isBlank()) {
            String pIdUpper = ctxPId.toUpperCase();
            Optional<Product> productOpt = productRepository.findByPId(pIdUpper);
            if (productOpt.isPresent()) {
                Product product = productOpt.get();
                config = deduplicationService.buildConfigFromCanonicalFieldNames(
                        product.getDeduplicationFields()
                );
                log.debug("Using per-product dedup config for pId {}: useEmail={}, usePhone={}, useAadhar={}",
                        pIdUpper, config.isUseEmail(), config.isUsePhone(), config.isUseAadhar());
            } else {
                config = canonicalFieldDeduplicationService.buildConfigFromCanonicalFields();
                log.warn("Product not found for pId {} while deduplicating; falling back to canonical-field config", pIdUpper);
            }
        } else {
            config = canonicalFieldDeduplicationService.buildConfigFromCanonicalFields();
            log.debug("No pId in UpsertContext; using canonical-field dedup config");
        }
        
        String email = normalized.get("email");
        String phone = normalized.get("phone_number");
        String aadhar = normalized.get("aadhar_number");
        
        // Try email if enabled in config
        if (config.isUseEmail() && email != null && !email.isEmpty()) {
            List<Lead> leads = leadRepository.findByEmail(email);
            if (!leads.isEmpty()) {
                log.debug("Found existing lead by email: {}", email);
                return Optional.of(leads.get(0));
            }
        }
        
        // Try phone if enabled in config
        if (config.isUsePhone() && phone != null && !phone.isEmpty()) {
            List<Lead> leads = leadRepository.findByPhoneNumber(phone);
            if (!leads.isEmpty()) {
                log.debug("Found existing lead by phone: {}", phone);
                return Optional.of(leads.get(0));
            }
        }
        
        // Try aadhar if enabled in config
        if (config.isUseAadhar() && aadhar != null && !aadhar.isEmpty()) {
            List<Lead> leads = leadRepository.findByAadharNumber(aadhar);
            if (!leads.isEmpty()) {
                log.debug("Found existing lead by aadhar: {}", aadhar);
                return Optional.of(leads.get(0));
            }
        }
        
        return Optional.empty();
    }
    
    private Lead mergeLeadData(Lead existing, Map<String, String> incoming, UpsertContext ctx) {
        // Fill missing fields
        if ((existing.getName() == null || existing.getName().isEmpty()) && incoming.get("name") != null) {
            existing.setName(incoming.get("name"));
        }
        if ((existing.getPhoneNumber() == null || existing.getPhoneNumber().isEmpty()) && incoming.get("phone_number") != null) {
            existing.setPhoneNumber(incoming.get("phone_number"));
        }
        if ((existing.getEmail() == null || existing.getEmail().isEmpty()) && incoming.get("email") != null) {
            existing.setEmail(incoming.get("email"));
        }
        if ((existing.getAadharNumber() == null || existing.getAadharNumber().isEmpty()) && incoming.get("aadhar_number") != null) {
            existing.setAadharNumber(incoming.get("aadhar_number"));
        }
        if (existing.getIncome() == null && ctx.getIncome() != null) {
            existing.setIncome(ctx.getIncome());
        }
        if (existing.getCreditScore() == null && ctx.getCreditScore() != null) {
            existing.setCreditScore(ctx.getCreditScore());
        }
        if (existing.getEmploymentType() == null && ctx.getEmploymentType() != null) {
            existing.setEmploymentType(ctx.getEmploymentType());
        }
        if (existing.getLoanAmount() == null && ctx.getLoanAmount() != null) {
            existing.setLoanAmount(ctx.getLoanAmount());
        }
        if (existing.getConverted() == null && ctx.getConverted() != null) {
            existing.setConverted(ctx.getConverted());
        }
        
        // Track source and product history
        if (!existing.getSourcesSeen().contains(ctx.sourceId)) {
            existing.getSourcesSeen().add(ctx.sourceId);
        }
        if (!existing.getProductsSeen().contains(ctx.pId)) {
            existing.getProductsSeen().add(ctx.pId);
        }
        
        // Store raw row for audit trail
        Lead.MergeRecord mergeRecord = Lead.MergeRecord.builder()
                .timestamp(LocalDateTime.now())
                .sourceId(ctx.sourceId)
                .pId(ctx.pId)
                .data(ctx.rawRow)
                .build();
        
        existing.getMergedFrom().add(mergeRecord);
        
        return existing;
    }
    
    public static class UpsertResult {
        private final String action; // "inserted" or "merged"
        private final Lead lead;
        
        public UpsertResult(String action, Lead lead) {
            this.action = action;
            this.lead = lead;
        }
        
        public String getAction() { return action; }
        public Lead getLead() { return lead; }
    }
    
    public static class UpsertContext {
        private final String pId;
        private final String sourceId;
        private final Object rawRow;
        private final Integer income;
        private final Integer creditScore;
        private final Lead.EmploymentType employmentType;
        private final Integer loanAmount;
        private final Boolean converted;
        
        public UpsertContext(String pId, String sourceId, Object rawRow) {
            this(pId, sourceId, rawRow, null, null, null, null, null);
        }

        public UpsertContext(String pId, String sourceId, Object rawRow,
                             Integer income, Integer creditScore, Lead.EmploymentType employmentType,
                             Integer loanAmount, Boolean converted) {
            this.pId = pId;
            this.sourceId = sourceId;
            this.rawRow = rawRow;
            this.income = income;
            this.creditScore = creditScore;
            this.employmentType = employmentType;
            this.loanAmount = loanAmount;
            this.converted = converted;
        }
        
        public String getPId() { return pId; }
        public String getSourceId() { return sourceId; }
        public Object getRawRow() { return rawRow; }
        public Integer getIncome() { return income; }
        public Integer getCreditScore() { return creditScore; }
        public Lead.EmploymentType getEmploymentType() { return employmentType; }
        public Integer getLoanAmount() { return loanAmount; }
        public Boolean getConverted() { return converted; }
    }
}
